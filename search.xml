<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[51Nod1229]序列求和V2</title>
      <link href="2019/06/24/51Nod1229/"/>
      <url>2019/06/24/51Nod1229/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.51nod.com/Challenge/Problem.html#!#problemId=1229" target="_blank" rel="noopener">题目链接</a><br>题意；求$\sum_{i=1}^n i^kr^i$模$1e9 + 7$。($n, r \le 10^{18}$，$k \le 2000$)。</p><p>设$f(n, k) = \sum_{i=1}^n i^kr^i$。<br>$rf(n, k) = \sum_{i=1}^n i^kr^{i+1} = \sum_{i=2}^{n+1} (i-1)^kr^i$。<br>$f(n, k) - rf(n, k) = r - n^kr^{n+1} + \sum_{i=2}^n \Big (i^k - (i-1)^k \Big )r^i$。<br>$(1 -r)f(n, k) = r - n^kr^{n+1} - \sum_{i=2}^n\sum_{j=0}^{k-1} (-1)^{k-j} \big ( {k \atop j} \big ) i^jr^i$<br>$(1 - r)f(n, k) = r - n^kr^{n+1} - \sum_{j=0}^{k-1}(-1)^{k-j}\big ( {k \atop j} \big ) \sum_{i=2}^n i^jr^i$。<br>$f(n, k) = \frac{1}{1 - r}\Big (r - n^kr^{n+1} - \sum_{j=0}^{k-1}(-1)^{k-j}\big ( {k \atop j} \big ) (f(n, j) - r) \Big)$。<br>当$r &gt; 1$的时候可以递推。$r = 1$需要特判，写一个自然数幂和。<br>复杂度$O(k^2)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3000</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> t, f[maxn + <span class="number">10</span>], comb[maxn + <span class="number">10</span>][maxn + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> inv[maxn + <span class="number">10</span>], ifac[maxn + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> pre[maxn + <span class="number">10</span>], suf[maxn + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> k, r;</span><br><span class="line">ll n, tmpr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">x += y; <span class="keyword">return</span> x &lt; mod ? x : x - mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">x -= y; <span class="keyword">return</span> x &lt; <span class="number">0</span> ? x + mod : x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1l</span>l * x * y % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> x, ll y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (y) &#123;</span><br><span class="line"><span class="keyword">if</span> (y &amp; <span class="number">1</span>) ans = mul(ans, x);</span><br><span class="line">y &gt;&gt;= <span class="number">1</span>; x = mul(x, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ifac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxn; ++i) &#123;</span><br><span class="line">inv[i] = i == <span class="number">1</span> ? <span class="number">1</span> : dec(<span class="number">0</span>, mul(mod / i, inv[mod % i]));</span><br><span class="line">ifac[i] = mul(ifac[i - <span class="number">1</span>], inv[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxn; ++i) &#123;</span><br><span class="line">comb[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) comb[i][j] = add(comb[i - <span class="number">1</span>][j], comb[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">init();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"><span class="keyword">while</span> (t--) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%d%lld"</span>, &amp;n, &amp;k, &amp;tmpr);</span><br><span class="line">r = tmpr % mod;</span><br><span class="line"><span class="keyword">if</span> (r == <span class="number">1</span>) &#123;</span><br><span class="line">pre[<span class="number">0</span>] = suf[k + <span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k + <span class="number">2</span>; ++i)</span><br><span class="line">pre[i] = mul(pre[i - <span class="number">1</span>], dec(n % mod, i));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = k + <span class="number">2</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">suf[i] = mul(suf[i + <span class="number">1</span>], dec(n % mod, i));</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, now = <span class="number">0</span>; i &lt;= k + <span class="number">2</span>; ++i) &#123;</span><br><span class="line">now = add(now, fpow(i, k));</span><br><span class="line"><span class="keyword">int</span> w = mul(ifac[i - <span class="number">1</span>], ifac[k + <span class="number">2</span> - i]);</span><br><span class="line"><span class="keyword">if</span> ((k + <span class="number">2</span> - i) &amp; <span class="number">1</span>) w = dec(<span class="number">0</span>, w);</span><br><span class="line">ans = add(ans, mul(mul(now, w), mul(pre[i - <span class="number">1</span>], suf[i + <span class="number">1</span>])));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">f[<span class="number">0</span>] = dec(mul(dec(fpow(r, n + <span class="number">1</span>), <span class="number">1</span>), fpow(dec(r, <span class="number">1</span>), mod - <span class="number">2</span>)), <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">f[i] = dec(r, mul(fpow(n % mod, i), fpow(r, n + <span class="number">1</span>)));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line"><span class="keyword">int</span> w = mul(comb[i][j], dec(f[j], r));</span><br><span class="line"><span class="keyword">if</span> ((i - j) &amp; <span class="number">1</span>) f[i] = add(f[i], w);</span><br><span class="line"><span class="keyword">else</span> f[i] = dec(f[i], w);</span><br><span class="line">&#125;</span><br><span class="line">f[i] = mul(f[i], fpow(dec(<span class="number">1</span>, r), mod - <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[NOI2013]树的计数</title>
      <link href="2019/06/20/uoj122/"/>
      <url>2019/06/20/uoj122/</url>
      
        <content type="html"><![CDATA[<p>这题几个星期前看了一下午题解没看懂，现在看了一会就看懂了。可能是我太蠢了。</p><a id="more"></a><p><a href="http://uoj.ac/problem/122" target="_blank" rel="noopener">题目链接</a><br>题意：给一棵树的dfs序和bfs序，求树高的期望，保留3位小数。($n \le 200000$)</p><p>先把节点重标号，把bfs序为$i$的节点标号为$i$。<br>设$a_i$为$i$的dfs序，$b_i$为dfs序为$i$的节点(即$a_{b_i} = i$)， $i$的深度为$d_i$，那么一种划分方案合法当且仅当：</p><ul><li>$d_1 = 1, d_2 = 2$。</li><li>$d_i \le d_{i + 1} \le d_i + 1$。</li><li>如果$a_i &gt; a_{i + 1}$，那么$d_{i+1} = d_i + 1$。</li><li>如果$b_i &lt; b_{i + 1}$，那么$d_{b_{i + 1}} - d_{b_i} \le 1$</li></ul><p>上述条件的必要性显然，对于充分性的证明，可以给出一种构造：<br>按dfs序枚举所有节点，维护一个栈表示从1号点到当前点的路径上所有节点，那么当新加入一个点的时候：</p><ul><li>如果栈顶节点的深度$+1=$当前节点深度，那么把当前节点置为栈顶节点最靠右的孩子，并把当前节点插入栈中。</li><li>否则一定有当前节点的深度$\le$栈顶节点的深度，不断从栈中弹出节点，直到满足上一条的条件，进行上一条的操作即可。</li></ul><p>对于这个构造的正确性：</p><ul><li>每个节点的深度是正确的。</li><li>对于深度相同的一段，根据上述条件，它们的dfs序一定是递增的。那么，对于深度相同的节点，它们的相对顺序没有改变。</li></ul><p>那么构造的正确性得到了证明，上述条件的充要性得证了。同时，根据构造过程，可以发现一种合法的$d$一定恰好对应着一种方案，那么就是要求所有合法的$d$的$d_n$的期望。<br>一种合法的$d$可以对应成一个集合$S = \lbrace i | 1 \le i &lt; n, d_i + 1 = d_{i + 1} \rbrace$，深度就是$|S| + 1$。<br>如果一个$S$合法，根据上述条件，也有一些限制：</p><ul><li>根据第一、三个条件，需要满足$S$中一定要有$1$和某些特定元素，这些元素对答案的贡献是$1$。</li><li><p>根据第四个条件，对于$2 \le i &lt; n$，如果$b_i &lt; b_{i+1}$，需要满足$[b_i, b_{i + 1} )$中只有不超过一个元素在$S$中。那么也就是说：</p><ul><li>如果$b_i + 1 &lt; b_{i + 1}$，那么$b_i$和$b_{i + 1}$之间一定有一个因满足第三个条件而一定在$S$内的元素，那么$[b_i, b_{i + 1})$中不能有除了该元素之外的其它元素在$S$中。</li><li>否则有$b_i + 1 = b_{i + 1}$，如果$b_i$不是因为上一条的影响而不能在$S$中，那么$b_i$是否在$S$中可以任意选择，且不影响其它元素的选择。那么它对答案的贡献就是$0.5$。</li></ul></li></ul><p>根据上述方法计算答案即可。<br>复杂度$O(n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[maxn + <span class="number">10</span>], b[maxn + <span class="number">10</span>], c[maxn + <span class="number">10</span>], d[maxn + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">double</span> ans = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">a[x] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">b[i] = a[x]; c[b[i]] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i)</span><br><span class="line"><span class="keyword">if</span> (c[i] + <span class="number">1</span> &lt; c[i + <span class="number">1</span>]) &#123;</span><br><span class="line">++d[c[i]]; --d[c[i + <span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">d[i] += d[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (b[i] &gt; b[i + <span class="number">1</span>]) ++ans;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!d[i]) ans += <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.3lf"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 概率期望 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[AGC014F]Strange Sorting</title>
      <link href="2019/06/19/AGC014F/"/>
      <url>2019/06/19/AGC014F/</url>
      
        <content type="html"><![CDATA[<p>技不如人，甘拜下风。</p><a id="more"></a><p><a href="https://atcoder.jp/contests/agc014/tasks/agc014_f" target="_blank" rel="noopener">题目链接</a></p><p>题意：有一个排列$p$，每次操作会取出排列中所有$p_i = \max \lbrace p_j | 1 \le j \le i \rbrace$的所有元素，按原来的顺序移到序列的最后。问需要几次才能排好序。($n \le 250000$)</p><p>定义$q_i$为$i$的位置，即$p_{q_i} = i$。</p><p>设$T_i$为将所有$\ge i$的元素排好序的次数。容易发现可以忽视掉序列中$&lt; i$的元素，如果进行了$T_{i + 1}$次操作后，$i$是序列中$\ge i$的第一个元素，那么$T_i = T_{i + 1}$，否则$T_i = T_{i+1} + 1$。</p><p>设$f_i$为进行$T_i - 1$次操作后，序列中$\ge i$的第一个元素(如果$T_i = 0$，$f_i$无意义)，那么有$f_i &gt; i$。在计算$T_i$时，$T_i = T_{i+1}$当且仅当在进行了$T_{i+1} - 1$次操作后，$q_{f_{i+1}} &lt; q_i &lt; q_{i+1}$。</p><p>接下来证明一个结论：无论进行多少次操作，$f_{i+1}$、$i$、$i+1$这三个数的位置关系永远是旋转同构的($(a, b, c)$、$(b, c, a)$、$(c, a, b)$视为旋转同构)。</p><p>先证明一个引理：在进行操作的过程中，忽视$&lt; i$的元素，如果$f_i$不是第一个元素，那么它不会成为某一个前缀最大值。</p><p>证明如下：假设有一个不是第一个元素的前缀最大值，设它为$x$。设$x$之前的一个元素为$y$，有$y &lt; x$。进行若干次操作之后，如果$y$和$x$不相邻了，那么一定是在$y$之前存在一个$z$满足$y &lt; z &lt; x$。那么这次操作后$z$一定在$x$前一个位置。所以$x$之前一定有一个比$x$小的元素，所以$f_i \ne x$。</p><p>之后再证明结论：</p><p>对于$f_{i+1}, i, i + 1$这三个元素的位置关系，只要枚举一下所有情况，即可得证。上面的引理可以保证如果$i + 1$在$f_{i+1}$之前，那么$f_{i+1}$不会成为前缀最大值。</p><p>接下来就可以计算答案了($q_i$是还未进行操作时$i$的位置)：</p><p>如果$T_{i+1} = 0$：</p><ul><li>如果$q_i &lt; q_{i+1}$，$T_i = 0$。</li><li>否则$T_i = 1$，$f_i = i + 1$。</li></ul><p>否则：</p><ul><li>如果$q_{f_{i+1}}$、$q_i$、$q_{i+1}$这三个数的关系和它们排序之后的关系旋转同构，那么$T_i = T_{i+1}$，$f_i = f_{i + 1}$。</li><li>否则$T_i = T_{i+1} + 1$，$f_i = i + 1$。</li></ul><p>复杂度$O(n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">int</span> n, pos[maxn + <span class="number">10</span>], t[maxn + <span class="number">10</span>], f[maxn + <span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); pos[x] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line"><span class="keyword">if</span> (!t[i + <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">if</span> (pos[i] &lt; pos[i + <span class="number">1</span>]) t[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">t[i] = <span class="number">1</span>; f[i] = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> x = pos[f[i + <span class="number">1</span>]], y = pos[i], z = pos[i + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> ((x &lt; y) + (y &lt; z) + (z &lt; x) == <span class="number">2</span>) &#123;</span><br><span class="line">t[i] = t[i + <span class="number">1</span>]; f[i] = f[i + <span class="number">1</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">t[i] = t[i + <span class="number">1</span>] + <span class="number">1</span>; f[i] = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, t[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[Wannafly26F]msc的棋盘</title>
      <link href="2019/06/19/Wannafly26F/"/>
      <url>2019/06/19/Wannafly26F/</url>
      
        <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/212/F" target="_blank" rel="noopener">题目链接</a></p><p>题意：有一个$n \times m$的01矩阵，第$i$行的数之和为$A_i$，第$j$列的数之和为$B_j$，已知数组$B$的所有元素，求有多少种可能的数组$A$。模$10^9 + 7$。($1 \le n, m \le 50$)</p><p>先想如果给定数组$A$、$B$，如何判断是否合法。首先$A$的所有元素之和必定等于$B$的所有元素之和，记这个和为$x$。</p><p>之后使用网络流判断，建$n$个点表示行，起点向第$i$个点连容量$A_i$的边。建$m$个点表示列，第$i$个点向终点连容量$B_i$的边。之后表示行的每个点向表示列的每个点连容量为$1$的边。判断最大流是否为$x$即可。</p><p>观察这张图的最小割，假设起点连出去的边割了$i$条，连到终点的边割了$j$条，那一定是割了起点连出去容量最小的前$i$条边和连到终点的容量最小的前$j$条边，之后再割掉所有和起点或终点有边相邻的点之间的所有边。</p><p>设将$A$排序后的前缀和数组为$A’$，将$B$排序后的前缀和数组为$B’$，那么最小割为$\min \lbrace A’_i + B’_j + (n - i)(m - j) | 0 \le i \le n, 0 \le j \le m \rbrace$。</p><p>再考虑原问题，需要求有多少种$A$，满足所有数的和为$x$且上式的值为$x$。容易发现当$i = 0, j = m$时上式的值为$x$，那么只需要保证不存在一对$i, j$使得上式的值$&lt; x$。</p><p>可以发现这个问题可以很方便的使用动态规划计算。设$f(i, j, k)$为已经确定了$A$中所有$\le i$的数及其位置关系，$A$中$\le i$的数共$j$个，$A’_j = k$的方案数。转移可以通过枚举$A$中有多少个$= i + 1$的数来实现。</p><p>复杂度$O(n^3m^2)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, f[maxn + <span class="number">10</span>][maxn + <span class="number">10</span>][maxn * maxn + <span class="number">10</span>], comb[maxn + <span class="number">10</span>][maxn + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> a[maxn + <span class="number">10</span>], ans, minv[maxn + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addto</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">x += y; <span class="keyword">if</span> (x &gt;= mod) x -= mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1l</span>l * x * y % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">comb[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">addto(comb[i][j], comb[i - <span class="number">1</span>][j]);</span><br><span class="line">addto(comb[i][j], comb[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">sort(a + <span class="number">1</span>, a + m + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) a[i] += a[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">minv[i] = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++j)</span><br><span class="line">minv[i] = min(minv[i], a[j] + (n - i) * (m - j));</span><br><span class="line">&#125;</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; ++j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= n * m; ++k)</span><br><span class="line"><span class="keyword">if</span> (f[i][j][k]) &#123;</span><br><span class="line"><span class="keyword">int</span> sum = k;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = j; l &lt;= n; ++l) &#123;</span><br><span class="line"><span class="keyword">if</span> (sum + minv[l] &lt; a[m]) <span class="keyword">break</span>;</span><br><span class="line">addto(f[i + <span class="number">1</span>][l][sum], mul(f[i][j][k], comb[l][j]));</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, f[m + <span class="number">1</span>][n][a[m]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[LOJ6254]最优卡组</title>
      <link href="2019/06/13/LOJ6254/"/>
      <url>2019/06/13/LOJ6254/</url>
      
        <content type="html"><![CDATA[<p>爆搜过十万(误)。</p><a id="more"></a><p><a href="https://loj.ac/problem/6254" target="_blank" rel="noopener">题目链接</a></p><p>先二分第$n$大是几。</p><p>如何check呢？</p><p>首先可以写一个搜索，如果它搜出了$n$个$\ge mid$的方案，那肯定答案肯定$\ge mid$，否则答案$&lt; mid$。</p><p>然而这个算法是指数级的。</p><p>可以加一个剪枝，如果没有确定的数组都选最大值还是只能$&lt; mid$，那就退出。</p><p>分析一下这个算法的复杂度，在搜索树上一共有$n$个叶节点，这个搜索只会访问这$n$个叶节点的祖先。</p><p>所以这样的复杂度是$O(nk)$。（变成多项式的了，可喜可贺）</p><p>如果把搜索树上只有一个孩子的节点和它的孩子合并，那么搜索树上的节点个数就是$O(n)$的了。</p><p>也就是说在搜到一个点的时候，需要跳过只能选最大值、不能选次大值的那些数组。</p><p>那么可以将这$k$个数组按照最大值$-$次大值从小到大排序。这样的话，如果当前数组只能选最大值、不能选次大值，那么之后的数组也都不行，这种情况可以直接跳到叶节点。</p><p>这样check的复杂度就变成$O(n)$的了。</p><p>假设二分出来的答案是$ans$，如何输出答案呢？</p><p>使用上面的方法搜出$\ge ans + 1$的所有解，这样会搜出不到$n$个值，剩下的值一定全都是$ans$。</p><p>复杂度$O(n \log v)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt; a[maxn + <span class="number">10</span>], b;</span><br><span class="line">ll s[maxn + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;ll&gt; &amp;a, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;ll&gt; &amp;b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a[<span class="number">0</span>] - a[<span class="number">1</span>] &lt; b[<span class="number">0</span>] - b[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> p, ll sum, ll lim)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (sum + s[p] &lt; lim) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (p == k + <span class="number">1</span>) b.push_back(sum);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (sum + s[p] - a[p][<span class="number">0</span>] + a[p][<span class="number">1</span>] &lt; lim) dfs(k + <span class="number">1</span>, sum + s[p], lim);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)a[p].size(); ++i)</span><br><span class="line"><span class="keyword">if</span> (sum + a[p][i] + s[p + <span class="number">1</span>] &lt; lim) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">dfs(p + <span class="number">1</span>, sum + a[p][i], lim);</span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">int</span>)b.size() == n) <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;k, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> m; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line"><span class="keyword">while</span> (m--) &#123;</span><br><span class="line"><span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">a[i].push_back(x);</span><br><span class="line">&#125;</span><br><span class="line">a[i].push_back(<span class="number">-1e18</span>);</span><br><span class="line">sort(a[i].begin(), a[i].end(), greater&lt;ll&gt;());</span><br><span class="line">&#125;</span><br><span class="line">sort(a + <span class="number">1</span>, a + k + <span class="number">1</span>, cmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &gt;= <span class="number">1</span>; --i) s[i] = s[i + <span class="number">1</span>] + a[i][<span class="number">0</span>];</span><br><span class="line">ll l = <span class="number">0</span>, r = <span class="number">1e18</span>, ans;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">b.clear(); dfs(<span class="number">1</span>, <span class="number">0</span>, mid);</span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">int</span>)b.size() == n) ans = mid, l = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">b.clear(); dfs(<span class="number">1</span>, <span class="number">0</span>, ans + <span class="number">1</span>);</span><br><span class="line">sort(b.begin(), b.end(), greater&lt;ll&gt;());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)b.size(); ++i)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld "</span>, b[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - (<span class="keyword">int</span>)b.size(); ++i)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld "</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[LOJ6213]「美团 CodeM 决赛」radar</title>
      <link href="2019/06/13/LOJ6213/"/>
      <url>2019/06/13/LOJ6213/</url>
      
        <content type="html"><![CDATA[<p>斜率优化什么的太难写了啊。。。。</p><a id="more"></a><p><a href="https://loj.ac/problem/6213" target="_blank" rel="noopener">题目链接</a></p><p>首先发现，一个三角形高度越高，它新增一格高度的时候增加的面积就越多。那么一个三角形要么就不选，要么就提升到最高。</p><p>那么把每个三角形按照右端点排序，然后dp。假设$f(i)$表示决定了第前$i - 1$个三角形的选择情况，且选择了第$i$个三角形的最优收益，那么$f(i) = \max \lbrace f(j) - s(i, j) | 1 \le j &lt; i \rbrace + a_i - cost_i$（$s(i, j)$表示第$i$个三角形和第$j$个三角形重合的面积，$a_i$表示第$i$个三角形的面积，$cost_i$表示把第$i$个三角形提到最高的代价）。</p><p>设$l_i$为第$i$个三角形的左端点，$r_i$为第$i$个三角形的右端点，那么如果$r_j &lt; l_i$，那么$s(i, j) = 0$，否则$s(i, j) = \frac{(r_j - l_i)^2}{4}$。注意的$l_j &gt; l_i$的时候，这个式子是不对的，但是可以证明直接这么计算并没有关系。证明如下：</p><ul><li>可以发现$f(i)$不会从$l_j &gt; l_i$的三角形转移过来，因为这样三角形$i$包含了三角形$j$，显然是不优的。但是可以把这样的$j$的考虑进来，因为这样算出来的重合面积$&gt;$实际的重合面积。</li></ul><p>处理$r_j &lt; l_i$的转移的时候，可以维护一下前缀的$\max$，然后二分出最大的$j$满足$r_j &lt; l_i$。</p><p>处理剩下的的转移的时候，可以直接忽视$r_j \ge l_i$的限制，直接把$s(i, j)$视作$\frac{(r_j - l_i)^2}{4}$。因为这样的话$s(i, j) \ge 0$，肯定不比把$s(i, j)$视作$0$优。</p><p>然后使用斜率优化就可以解决此题了。</p><p>然而由于我太懒了，写了一个$O(n \log^2 n)$的好写做法。</p><p>因为可以使用斜率优化，所以这个问题是决策单调的。决策单调如果离线，有一个好写的分治做法。由于这题是在线的，在外面套一层cdq分治即可。</p><p>实现的时候为了避免小数，把所有值都乘了$4$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, c[maxn + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> l, r;</span><br><span class="line">ll w;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> data &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> r &lt; t.r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;a[maxn + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a[x].l &lt; a[y].l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll suf[maxn + <span class="number">10</span>], f[maxn + <span class="number">10</span>], ans;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">work</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> f[x] - <span class="number">1l</span>l * (a[x].r - a[y].l) * (a[x].r - a[y].l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ls, <span class="keyword">int</span> rs)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, id = <span class="number">-1</span>;</span><br><span class="line">ll val = <span class="number">-1e18</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = ls; i &lt;= rs; ++i) &#123;</span><br><span class="line">ll w = work(i, c[mid]);</span><br><span class="line"><span class="keyword">if</span> (w &gt; val) &#123;</span><br><span class="line">val = w; id = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">f[c[mid]] = max(f[c[mid]], val);</span><br><span class="line">calc(l, mid - <span class="number">1</span>, ls, id);</span><br><span class="line">calc(mid + <span class="number">1</span>, r, id, rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r) &#123;</span><br><span class="line"><span class="keyword">int</span> ls = <span class="number">1</span>, rs = l - <span class="number">1</span>, p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (ls &lt;= rs) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (ls + rs) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (a[mid].r &lt; a[l].l) p = mid, ls = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> rs = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">f[l] = max(f[l], suf[p]) + a[l].w;</span><br><span class="line">suf[l] = max(suf[l - <span class="number">1</span>], f[l]);</span><br><span class="line">ans = max(ans, f[l]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">solve(l, mid);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= r; ++i) c[i] = i;</span><br><span class="line">sort(c + mid + <span class="number">1</span>, c + r + <span class="number">1</span>, cmp);</span><br><span class="line">calc(mid + <span class="number">1</span>, r, l, mid);</span><br><span class="line">solve(mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"><span class="keyword">while</span> (t--) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n); ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> x, y, c; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;c);</span><br><span class="line">a[i] = (data)&#123;x - y, x + y, <span class="number">4l</span>l * y * y - <span class="number">4l</span>l * c * y&#125;;</span><br><span class="line">f[i] = suf[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">solve(<span class="number">1</span>, n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld.%02lld\n"</span>, ans / <span class="number">4</span>, ans % <span class="number">4</span> * <span class="number">25</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[LOJ6610]applese 爱数图</title>
      <link href="2019/05/07/LOJ6610/"/>
      <url>2019/05/07/LOJ6610/</url>
      
        <content type="html"><![CDATA[<p>一道自己出的小菜题。</p><a id="more"></a><p><a href="https://loj.ac/problem/6610" target="_blank" rel="noopener">题目链接</a></p><p>题意：有多少张无自环、无重边的 $n$ 个点带标号无向连通图，它的生成树个数 $ \leqslant k $。（$n \leqslant 10^6$，$k \leqslant 22$）</p><p>一张图的生成树个数为每个点双生成树个数之积。</p><p>一个点数$&gt; 2$的点双，生成树个数至少为$3$。那么点数$&gt; 2$的点双不超过$2$个。</p><p>对于一个点双，如果$m = n$，那么只能是一个环，生成树个数为$n$，方案数为$\frac{(n - 1)!}{2}$。</p><p>对于一个点双，如果$m = n + 1$，一定是两个点之间三条路径，观察一下发现生成树个数最少的情况是这三条路径中的两条长分别为$1$和$2$，此时生成树个数为$3n - 4$。（证明较为简单，就不讲了）</p><p>那么如果一个点双需要满足$m \geqslant n + 1$，因为$k \leqslant 22$，所以$n$必须$\leqslant 8$。那么我们可以在$2^{\frac{1}{2}n(n-1)}n^3$的时间内用搜索$+$矩阵树对于$\leqslant 8$的$n$打出一张表，内容为$n$个点生成树个数为$i(i \leqslant 22)$的点双一共有多少种。</p><p>最后枚举两个点双的大小、生成树个数，随便算一下答案就好了。</p><p>（打表程序本机需要跑$8\text{min}$。)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>, mod = <span class="number">998244353</span>, inv2 = (mod + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">100</span>][<span class="number">100</span>], n, s, ans, tot;</span><br><span class="line"><span class="keyword">int</span> fac[maxn + <span class="number">10</span>], inv[maxn + <span class="number">10</span>], ifac[maxn + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">x += y; <span class="keyword">return</span> x &lt; mod ? x : x - mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">x -= y; <span class="keyword">return</span> x &lt; <span class="number">0</span> ? x + mod : x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1l</span>l * x * y % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (y &lt; <span class="number">0</span>) <span class="keyword">return</span> fpow(fpow(x, -y), mod - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (y) &#123;</span><br><span class="line"><span class="keyword">if</span> (y &amp; <span class="number">1</span>) ans = mul(ans, x);</span><br><span class="line">y &gt;&gt;= <span class="number">1</span>; x = mul(x, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">f[<span class="number">3</span>][<span class="number">3</span>]=<span class="number">1</span>;</span><br><span class="line">f[<span class="number">4</span>][<span class="number">4</span>]=<span class="number">3</span>;</span><br><span class="line">f[<span class="number">4</span>][<span class="number">8</span>]=<span class="number">6</span>;</span><br><span class="line">f[<span class="number">4</span>][<span class="number">16</span>]=<span class="number">1</span>;</span><br><span class="line">f[<span class="number">5</span>][<span class="number">5</span>]=<span class="number">12</span>;</span><br><span class="line">f[<span class="number">5</span>][<span class="number">11</span>]=<span class="number">60</span>;</span><br><span class="line">f[<span class="number">5</span>][<span class="number">12</span>]=<span class="number">10</span>;</span><br><span class="line">f[<span class="number">5</span>][<span class="number">20</span>]=<span class="number">10</span>;</span><br><span class="line">f[<span class="number">5</span>][<span class="number">21</span>]=<span class="number">60</span>;</span><br><span class="line">f[<span class="number">6</span>][<span class="number">6</span>]=<span class="number">60</span>;</span><br><span class="line">f[<span class="number">6</span>][<span class="number">14</span>]=<span class="number">360</span>;</span><br><span class="line">f[<span class="number">6</span>][<span class="number">15</span>]=<span class="number">180</span>;</span><br><span class="line">f[<span class="number">6</span>][<span class="number">16</span>]=<span class="number">180</span>;</span><br><span class="line">f[<span class="number">7</span>][<span class="number">7</span>]=<span class="number">360</span>;</span><br><span class="line">f[<span class="number">7</span>][<span class="number">17</span>]=<span class="number">2520</span>;</span><br><span class="line">f[<span class="number">7</span>][<span class="number">19</span>]=<span class="number">2520</span>;</span><br><span class="line">f[<span class="number">7</span>][<span class="number">20</span>]=<span class="number">1260</span>;</span><br><span class="line">f[<span class="number">7</span>][<span class="number">21</span>]=<span class="number">1260</span>;</span><br><span class="line">f[<span class="number">8</span>][<span class="number">8</span>]=<span class="number">2520</span>;</span><br><span class="line">f[<span class="number">8</span>][<span class="number">20</span>]=<span class="number">20160</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>; i &lt;= <span class="number">22</span>; ++i)</span><br><span class="line">f[i][i] = mul(f[i - <span class="number">1</span>][i - <span class="number">1</span>], i - <span class="number">1</span>);</span><br><span class="line">fac[<span class="number">0</span>] = ifac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxn; ++i) &#123;</span><br><span class="line">inv[i] = i == <span class="number">1</span> ? <span class="number">1</span> : dec(<span class="number">0</span>, mul(mod / i, inv[mod % i]));</span><br><span class="line">fac[i] = mul(fac[i - <span class="number">1</span>], i);</span><br><span class="line">ifac[i] = mul(ifac[i - <span class="number">1</span>], inv[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">comb</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> mul(fac[x], mul(ifac[y], ifac[x - y]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">pre();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;s);</span><br><span class="line">ans = fpow(n, n - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= <span class="number">22</span>; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">3</span>; j &lt;= <span class="number">22</span>; ++j)</span><br><span class="line"><span class="keyword">if</span> (i &lt;= n &amp;&amp; j &lt;= s) &#123;</span><br><span class="line">ans = add(ans, mul(comb(n, i), mul(f[i][j], mul(i, fpow(n, n - i - <span class="number">1</span>)))));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= <span class="number">22</span>; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">3</span>; j &lt;= <span class="number">22</span>; ++j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">3</span>; k &lt;= <span class="number">22</span>; ++k)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">3</span>; l &lt;= <span class="number">22</span>; ++l) &#123;</span><br><span class="line"><span class="keyword">if</span> (i + k &lt;= n &amp;&amp; j * l &lt;= s) &#123;</span><br><span class="line"><span class="keyword">int</span> w = mul(comb(n, i), comb(n - i, k));</span><br><span class="line">w = mul(w, mul(i, k));</span><br><span class="line">w = mul(w, fpow(n, n - i - k));</span><br><span class="line">w = mul(w, mul(f[i][j], f[k][l]));</span><br><span class="line">tot = add(tot, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i + k - <span class="number">1</span> &lt;= n &amp;&amp; j * l &lt;= s) &#123;</span><br><span class="line"><span class="keyword">int</span> w = mul(n, mul(comb(n - <span class="number">1</span>, i - <span class="number">1</span>), comb(n - i, k - <span class="number">1</span>)));</span><br><span class="line">w = mul(w, i + k - <span class="number">1</span>);</span><br><span class="line">w = mul(w, fpow(n, n - i - k));</span><br><span class="line">w = mul(w, mul(f[i][j], f[k][l]));</span><br><span class="line">tot = add(tot, w);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans = add(ans, mul(tot, inv2));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 搜索 </tag>
            
            <tag> 矩阵树定理 </tag>
            
            <tag> 计数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[LUOGU3922]中学数学题</title>
      <link href="2019/04/16/LUOGU3922/"/>
      <url>2019/04/16/LUOGU3922/</url>
      
        <content type="html"><![CDATA[<p>做不来小学数学题了。</p><a id="more"></a><p><a href="https://www.luogu.org/problemnew/show/P3922" target="_blank" rel="noopener">题目链接</a></p><p>题意：求$2^0, 2^1, 2^2, 2^3, \dots , 2^k$中一共有多少个数最高位为$4$。（$k \leqslant 10^{233}$) </p><p>我们有一个数$x=1$，每次操作要把$x$乘$2$。重复$k$次。然后我们就是要求有多少次操作结束后$x$的最高位为$4$。</p><p>进行一次操作后，如果$x$的位数加了$1$，那么$x$的最高位必定为$1$，否则$x$的最高位就会$\times 2$或$\times 2 +1 $。假设当前$x$的最高位为$1$，设再进行$i$次操作后$x$的位数恰好加了一。显然$i=3$或$4$。在这个过程中可能的最高位变化序列不多，枚举一下发现如果$i=3$，那么最高位变化序列中一定没有$4$，否则一定有$4$。</p><p>我们先假设$2^k$的最高位为$1$（如果不是，我们把最后一段操作的贡献单独计算一下）。那么我们就是要求：有多少次，我们使用了四次操作使得$x$的位数恰好加了$1$。设答案为$y$，如果$2^k$一共有$b$位，我们就是需要解方程$4y + 3(b-1-y) = k$。那么$y=k + 3 - 3b$。对于求$b$的值，容易发现$b = \lfloor log_{10}{2^k} \rfloor + 1 = \lfloor k \log_{10}2 \rfloor + 1$。</p><p>对于高精度部分：当然是使用$\text{python}$辣！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> getcontext</span><br><span class="line">getcontext().prec = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getdig</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="keyword">return</span> int(Decimal(<span class="string">'2'</span>).log10() * n)</span><br><span class="line"></span><br><span class="line">t, n=map(int, input().split())</span><br><span class="line"><span class="keyword">if</span> t == <span class="number">0</span>:</span><br><span class="line">n = <span class="number">10</span> ** n</span><br><span class="line"></span><br><span class="line">d = getdig(n)</span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line"><span class="keyword">if</span> getdig(i) == d:</span><br><span class="line">cnt += <span class="number">1</span></span><br><span class="line">nn = i</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">print(nn - <span class="number">3</span> * d + (cnt == <span class="number">4</span> <span class="keyword">or</span> (cnt == <span class="number">3</span> <span class="keyword">and</span> getdig(n + <span class="number">1</span>) == d)))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[HNOI2019]校园旅行</title>
      <link href="2019/04/10/uoj465/"/>
      <url>2019/04/10/uoj465/</url>
      
        <content type="html"><![CDATA[<p>我没有脑子。</p><a id="more"></a><p><a href="http://uoj.ac/problem/465" target="_blank" rel="noopener">题目链接</a></p><p>题意：给你一张$n$个点$m$条边的无向图，每个点有$0$或$1$的点权，$q$组询问，每组询问$x$和$y$，求是否存在一条从$x$到$y$的路径，满足这条路径上的点的点权按顺序拼接形成的字符串是回文串。（$n \leqslant 5000, m \leqslant 500000, q \leqslant 100000$）</p><p>我们用$f(i, j)$代表询问$i, j$的答案。我们要预处理出所有$f(i, j)$。</p><p>显然有一个$O(m^2)$的算法，我们一开始能确定$f(i, i) = 1$和$f(l, r) = 1$（$l$的点权和$r$的点权相同且$l$和$r$之间直接有边相邻），一旦我们确定$f(x, y) = 1$，如果$p$和$x$之间有边，$q$和$y$之间有边，并且$p$和$q$的点权相等，那么我们就能确定$f(p, q) = 1$。我们可以直接$\text{bfs}$或$\text{dfs}$出结果。</p><p>然后我们尝试删掉一些没有用的边。我们把所有连接两个点权为$1​$的点的边拿出来，它们构成的一个连通块如果是二分图，那么只要保留一棵生成树即可，否则保留一棵生成树，再增加加一个自环。（因为如果一条合法的路径中走过了删掉的边，我们可以走保留的生成树，然后让另一个点沿着当前边反复横跳，如果走的步数的奇偶性不对就沿着自环绕一圈）</p><p>然后对我们再对连接两个点权为$0$的点的边和连接两个点权不同的点的边都重复以上过程即可。这样边数就变成$O(n)$的了，复杂度就变成$O(n^2)$了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mkp make_pair</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5000</span>, maxm = <span class="number">500000</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, q, l[maxm + <span class="number">10</span>], r[maxm + <span class="number">10</span>], d[maxn + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">char</span> s[maxn + <span class="number">10</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[maxn + <span class="number">10</span>], z[maxn + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn + <span class="number">10</span>][maxn + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">bool</span> is = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)g[p].size(); ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> e = g[p][i];</span><br><span class="line"><span class="keyword">if</span> (d[e] == <span class="number">-1</span>) &#123;</span><br><span class="line">z[p].push_back(e); z[e].push_back(p);</span><br><span class="line">d[e] = d[p] ^ <span class="number">1</span>; is |= dfs(e);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (d[e] == d[p]) is = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) d[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">if</span> (d[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">d[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (dfs(i)) z[i].push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt; y) swap(x, y);</span><br><span class="line"><span class="keyword">if</span> (vis[x][y]) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">queue</span>&lt;pii&gt; q;</span><br><span class="line">vis[x][y] = <span class="number">1</span>;</span><br><span class="line">q.push(mkp(x, y));</span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">x = q.front().first; y = q.front().second;</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)z[x].size(); ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="keyword">int</span>)z[y].size(); ++j) &#123;</span><br><span class="line"><span class="keyword">int</span> xx = z[x][i], yy = z[y][j];</span><br><span class="line"><span class="keyword">if</span> (xx &gt; yy) swap(xx, yy);</span><br><span class="line"><span class="keyword">if</span> (!vis[xx][yy] &amp;&amp; s[xx] == s[yy]) &#123;</span><br><span class="line">vis[xx][yy] = <span class="number">1</span>; q.push(mkp(xx, yy));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l[i], &amp;r[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line"><span class="keyword">if</span> (s[l[i]] == <span class="string">'0'</span> &amp;&amp; s[r[i]] == <span class="string">'0'</span>) &#123;</span><br><span class="line">g[l[i]].push_back(r[i]);</span><br><span class="line">g[r[i]].push_back(l[i]);</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) g[i].clear();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line"><span class="keyword">if</span> (s[l[i]] == <span class="string">'1'</span> &amp;&amp; s[r[i]] == <span class="string">'1'</span>)  &#123;</span><br><span class="line">g[l[i]].push_back(r[i]);</span><br><span class="line">g[r[i]].push_back(l[i]);</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) g[i].clear();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line"><span class="keyword">if</span> (s[l[i]] != s[r[i]])  &#123;</span><br><span class="line">g[l[i]].push_back(r[i]);</span><br><span class="line">g[r[i]].push_back(l[i]);</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">calc(i, i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line"><span class="keyword">if</span> (s[l[i]] == s[r[i]]) calc(l[i], r[i]);</span><br><span class="line"><span class="keyword">while</span> (q--) &#123;</span><br><span class="line"><span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line"><span class="keyword">if</span> (x &gt; y) swap(x, y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, vis[x][y] ? <span class="string">"YES"</span> : <span class="string">"NO"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单位根反演</title>
      <link href="2019/04/07/wn-inversion/"/>
      <url>2019/04/07/wn-inversion/</url>
      
        <content type="html"><![CDATA[<p>我错了。</p><a id="more"></a><p>只是一个式子：$[k\ |\ n]=\frac{1}{k}\sum_{i=0}^{k-1}(\omega_k^i)^n$。</p><hr><p><a href="https://loj.ac/problem/6247" target="_blank" rel="noopener">LOJ6247</a></p><p>$\sum_{i \geqslant 0} [k \ | \ i] \big ( {n \atop i} \big) = \sum_{i \geqslant 0} \frac{1}{k}\sum_{j=0}^{k-1} (\omega_k^j)^i \big ( {n \atop i} \big) = \frac{1}{k} \sum_{j=0}^{k-1} \sum_{i \geqslant 0}(\omega_k^j)^i \big ( {n \atop i} \big ) = \frac{1}{k} = \sum_{j=0}^{k-1} (\omega_k^j + 1) ^ n$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> k, ans, wn;</span><br><span class="line">ll n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">x += y; <span class="keyword">return</span> x &lt; mod ? x : x - mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1l</span>l * x * y % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> x, ll y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (y) &#123;</span><br><span class="line"><span class="keyword">if</span> (y &amp; <span class="number">1</span>) ans = mul(ans, x);</span><br><span class="line">y &gt;&gt;= <span class="number">1</span>; x = mul(x, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%d"</span>, &amp;n, &amp;k);</span><br><span class="line">wn = fpow(<span class="number">3</span>, (mod - <span class="number">1</span>) / k);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, w = <span class="number">1</span>; i &lt; k; ++i, w = mul(w, wn)) </span><br><span class="line">ans = add(ans, fpow(add(w, <span class="number">1</span>), n));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, mul(ans, fpow(k, mod - <span class="number">2</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="http://uoj.ac/problem/450" target="_blank" rel="noopener">[集训队作业2018]复读机</a></p><p>一个复读机的生成函数为：$\sum_{i \geqslant 0} [d \ | \ i]\frac{x^i}{i!}=\sum_{i \geqslant 0} \frac{1}{d} \sum_{j=0}^{d-1} (\omega_d^j)^i \frac{x^i}{i!}= \frac{1}{d} \sum_{j=0}^{d-1}e^{\omega_d^jx}$。</p><p>我们要求这个生成函数的$k$次的$x^n$项系数。枚举对于每个$j$，$e^{\omega_d^jx}$被选了几次。注意到确定了前$d-1$项之后，最后一项被选了几次直接确定了。复杂度为$O(k^{d-1}\log n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500000</span>, mod = <span class="number">19491001</span>;</span><br><span class="line"><span class="keyword">int</span> n, inv[maxn + <span class="number">10</span>], fac[maxn + <span class="number">10</span>], ifac[maxn + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> k, d, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">x += y; <span class="keyword">return</span> x &lt; mod ? x : x - mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">x -= y; <span class="keyword">return</span> x &lt; <span class="number">0</span> ? x + mod : x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1l</span>l * x * y % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (y) &#123;</span><br><span class="line"><span class="keyword">if</span> (y &amp; <span class="number">1</span>) ans = mul(ans, x);</span><br><span class="line">y &gt;&gt;= <span class="number">1</span>; x = mul(x, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prework</span><span class="params">()</span> </span>&#123;</span><br><span class="line">fac[<span class="number">0</span>] = ifac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxn; ++i) &#123;</span><br><span class="line">fac[i] = mul(fac[i - <span class="number">1</span>], i);</span><br><span class="line">inv[i] = i == <span class="number">1</span> ? <span class="number">1</span> : dec(<span class="number">0</span>, mul(mod / i, inv[mod % i]));</span><br><span class="line">ifac[i] = mul(ifac[i - <span class="number">1</span>], inv[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">comb</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> mul(fac[x], mul(ifac[y], ifac[x - y]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">prework();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;k, &amp;d);</span><br><span class="line"><span class="keyword">if</span> (d == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d"</span>, fpow(k, n));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (d == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> wn = fpow(<span class="number">7</span>, (mod - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; ++i)</span><br><span class="line">ans = add(ans, mul(comb(k, i), fpow(add(i, mul(wn, k - i)), n)));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, mul(ans, fpow(fpow(d, k), mod - <span class="number">2</span>)));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> wn = fpow(<span class="number">7</span>, (mod - <span class="number">1</span>) / <span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; i + j &lt;= k; ++j)</span><br><span class="line">ans = add(ans, mul(comb(k, i), mul(comb(k - i, j), fpow(add(i, add(mul(wn, j), mul(mul(wn, wn), k - i - j))), n))));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, mul(ans, fpow(fpow(d, k), mod - <span class="number">2</span>)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZJOI2019day1爆零记</title>
      <link href="2019/03/29/zjoi2019day1/"/>
      <url>2019/03/29/zjoi2019day1/</url>
      
        <content type="html"><![CDATA[<p>自闭了。<br><a id="more"></a></p><p>我太菜了，做麻将题做了两个多小时，然后自闭了。我应该去做T3的。</p><p>（没想到我竟然能在ZJOI上发现T2这样一道我会做的题）</p><p>估分20+100+10=130。</p><hr><p>Update:</p><p>这个T1竟然比估分高了20分，得分40+100+10=150，勉强卡进省队线。</p><p>好像还有救?</p>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五边形数与整数拆分</title>
      <link href="2019/02/22/pentagonal-number/"/>
      <url>2019/02/22/pentagonal-number/</url>
      
        <content type="html"><![CDATA[<p>五边形数$p_i$定义为：$\frac{i(3i - 1)}{2}$。</p><p>一个定理：$\prod_{i=1}^{\infty} (1 - x^i) = \sum_{i=-\infty}^{\infty} (-1)^i x^{p_i}$。</p><p><a href="https://en.wikipedia.org/wiki/Pentagonal_number_theorem" target="_blank" rel="noopener">证明自行看维基。</a></p><p>接下来看一道题：</p><p><a href="https://loj.ac/problem/6268" target="_blank" rel="noopener">题目链接</a></p><p>题意：对于$1 \leqslant i \leqslant n$，求$i$的整数拆分方案数。$1 \leqslant n \leqslant 10^5$。</p><p>显然答案的生成函数为$\prod_{i=1}^{\infty} \frac{1}{1 - x^i}$。<del>然后我们就可以先ln再加起来再exp回去了。</del></p><p>那么我们就是要对$\prod_{i=1}^{\infty} (1 - x^i)$求逆。根据上面的定理，这个多项式在次数$\leqslant n$的时候非$0$的项数是$O(\sqrt{n})$级别的，那么我们就可以暴力求逆了，复杂度为$O(n\sqrt{n})$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span>, mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n, f[maxn + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">x -= y; <span class="keyword">return</span> x &lt; <span class="number">0</span> ? x + mod : x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1l</span>l * x * y % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n); f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">-300</span>; j &lt;= <span class="number">300</span>; ++j) &#123;</span><br><span class="line"><span class="keyword">int</span> v = j * (<span class="number">3</span> * j - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (v &lt;= i &amp;&amp; v) f[i] = dec(f[i], mul(f[i - v], j &amp; <span class="number">1</span> ? mod - <span class="number">1</span> : <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 生成函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[LOJ6267]生成随机数</title>
      <link href="2019/02/21/LOJ6267/"/>
      <url>2019/02/21/LOJ6267/</url>
      
        <content type="html"><![CDATA[<p><a href="https://loj.ac/problem/6267" target="_blank" rel="noopener">题目链接</a></p><p>题意：你有一个随机数生成器，有$\frac{1}{2}$的概率返回$0$，$\frac{1}{2}$的概率返回$1$。你要用它来构造一个新的随机数生成器，这个新的随机数生成器生成的数是$[1, n]$内的整数，且生成$i$的概率为$\frac{a_i}{a_1 + a_2 + \dots + a_n}$。求在调用一次新随机数生成器的过程中最少期望调用多少次原随机数生成器。$1 \leqslant n \leqslant 10^6$，$1 \leqslant \sum_{i=1}^n a_i \leqslant 10^7$。</p><p>我们把过程看成一棵无限大的完全二叉树，调用一次随机数生成器，如果是$0$就进入左子树，否则就进入右子树。那么经过一个深度为$i$的节点的概率为$2^{1-i}$。如果我们需要使生成$i$的概率为$p$，那么我们就是要选择一些节点(可能有无限个)，经过它们的概率之和为$p$，如果到达了一个被选择的节点，那么我们就直接返回$i$。</p><p>那么如果假设对于权值$i$，我们选择的节点集合为$S_i$，那么期望调用原随机数生成器的次数为$ \sum_{i=1}^{n} \sum_{j \in S_i} dep_j 2 ^ {1 - dep_j}$。我们定义$f(p)$为：我们找到一个节点集合$S$，使得经过它们的概率之和为$p$，且使$f(p)=\sum_{i \in S} dep_i 2 ^ {1 - dep_i}$最小。那么有一个显然的转移：</p><p>如果$p \geqslant \frac{1}{2}$，那么$f(p) = \frac{f(2(p - \frac{1}{2}))}{2} + p$(即选择一个根节点的孩子加入集合)，否则$f(p) = \frac{f(2p)}{2} + p$。我们发现对于$0 \leqslant i &lt; m$，$f(\frac{i}{m})$之间的转移关系构成了一棵基环森林，我们只要对在环上的部分解一下方程，对不在环上的部分直接转移即可。</p><p>时间复杂度$O(m)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10000000</span>, mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, invm, b[maxn + <span class="number">10</span>], bcnt, f[maxn + <span class="number">10</span>], vis[maxn + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> a[maxn + <span class="number">10</span>], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> mod = <span class="number">998244353</span>)</span> </span>&#123;</span><br><span class="line">x += y; <span class="keyword">return</span> x &lt; mod ? x : x - mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">x -= y; <span class="keyword">return</span> x &lt; <span class="number">0</span> ? x + mod : x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1l</span>l * x * y % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (y) &#123;</span><br><span class="line"><span class="keyword">if</span> (y &amp; <span class="number">1</span>) ans = mul(ans, x);</span><br><span class="line">y &gt;&gt;= <span class="number">1</span>; x = mul(x, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]); m += a[i];</span><br><span class="line">&#125;</span><br><span class="line">invm = fpow(m, mod - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line"><span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line"><span class="keyword">int</span> p = i; bcnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!vis[p]) &#123;</span><br><span class="line">b[++bcnt] = p;</span><br><span class="line">vis[p] = i + <span class="number">1</span>;</span><br><span class="line">p = add(p, p, m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (vis[p] == i + <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> x = (mod + <span class="number">1</span>) / <span class="number">2</span>, y = mul(p, invm);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = add(p, p, m); j != p; j = add(j, j, m)) &#123;</span><br><span class="line">y = add(y, mul(x, mul(j, invm)));</span><br><span class="line">x = mul(x, (mod + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">f[p] = mul(y, fpow(dec(<span class="number">1</span>, x), mod - <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = bcnt; j &gt;= <span class="number">1</span>; --j)</span><br><span class="line">f[b[j]] = add(mul(f[add(b[j], b[j], m)], (mod + <span class="number">1</span>) / <span class="number">2</span>), mul(b[j], invm));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ans = add(ans, f[a[i]]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[LOJ6187]Odd</title>
      <link href="2019/01/03/LOJ6187/"/>
      <url>2019/01/03/LOJ6187/</url>
      
        <content type="html"><![CDATA[<p><a href="https://loj.ac/problem/6187" target="_blank" rel="noopener">题目链接</a></p><p>题意：给你一个数组，求它有多少个子区间所有数都出现了奇数次。$n \leqslant 2 \times 10^5$。</p><p>首先给每一个数$\text{rand}$一个权值，那么一个区间满足条件等价于这个区间所有数的权值异或和$\text{xor}$上这个区间去重后的所有数的权值异或和为$0$。</p><p>然后我们从左到右枚举区间的右端点，然后维护每个左端点的权值。我们定义$pre[i]$为上一个与位置$i$上的数相等的位置，那么右端点移到$i$时，左端点在$[1,pre[i]]$的所有区间的权值都会异或上位置$i$上的数的权值。</p><p>然后我们就是需要支持区间$\text{xor}$一个数，查询有多少个$0$。这个东西显然可以用分块解决。</p><p>复杂度$O(n\sqrt{n})$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200000</span>, maxv = <span class="number">1000000</span>, blksz = <span class="number">500</span>, mod = <span class="number">100003</span>;</span><br><span class="line"><span class="keyword">int</span> n, pre[maxn + <span class="number">10</span>], lst[maxv + <span class="number">10</span>];</span><br><span class="line">ull w[maxv + <span class="number">10</span>], val[maxn + <span class="number">10</span>], tag[maxn / blksz + <span class="number">10</span>], ans;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hshtb</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> h[mod], cnt[blksz + <span class="number">10</span>], ccnt, nxt[blksz + <span class="number">10</span>];</span><br><span class="line">    ull val[blksz + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ccnt; ++i)</span><br><span class="line">            h[val[i] % mod] = <span class="number">0</span>;</span><br><span class="line">        ccnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>&amp; <span class="keyword">operator</span>[] (ull v) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[v % mod]; i; i = nxt[i])</span><br><span class="line">            <span class="keyword">if</span> (val[i] == v) <span class="keyword">return</span> cnt[i];</span><br><span class="line">        val[++ccnt] = v; cnt[ccnt] = <span class="number">0</span>; </span><br><span class="line">        nxt[ccnt] = h[v % mod]; h[v % mod] = ccnt;</span><br><span class="line">        <span class="keyword">return</span> cnt[ccnt];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(ull v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[v % mod]; i; i = nxt[i])</span><br><span class="line">            <span class="keyword">if</span> (val[i] == v) <span class="keyword">return</span> cnt[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;mp[maxn / blksz + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> p, ull v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; (i - <span class="number">1</span>) * blksz + <span class="number">1</span> &lt;= p; ++i)</span><br><span class="line">        <span class="keyword">if</span> (i * blksz &lt;= p) tag[i] ^= v;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = (i - <span class="number">1</span>) * blksz + <span class="number">1</span>; j &lt;= i * blksz &amp;&amp; j &lt;= n; ++j) &#123;</span><br><span class="line">                val[j] ^= tag[i];</span><br><span class="line">            &#125;</span><br><span class="line">            tag[i] = <span class="number">0</span>; mp[i].clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = (i - <span class="number">1</span>) * blksz + <span class="number">1</span>; j &lt;= i * blksz &amp;&amp; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt;= p) val[j] ^= v;</span><br><span class="line">                ++mp[i][val[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ull <span class="title">query</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    ull ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; (i - <span class="number">1</span>) * blksz + <span class="number">1</span> &lt;= p; ++i)</span><br><span class="line">        <span class="keyword">if</span> (i * blksz &lt;= p) ans += mp[i].ask(tag[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">for</span> (<span class="keyword">int</span> j = (i - <span class="number">1</span>) * blksz + <span class="number">1</span>; j &lt;= p; ++j)</span><br><span class="line">            ans += !(val[j] ^ tag[i]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    w[<span class="number">0</span>] = <span class="number">131</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxv; ++i) &#123;</span><br><span class="line">        w[i] = w[i - <span class="number">1</span>];</span><br><span class="line">        w[i] ^= w[i] &lt;&lt; <span class="number">13</span>;</span><br><span class="line">        w[i] ^= w[i] &gt;&gt; <span class="number">17</span>;</span><br><span class="line">        w[i] ^= w[i] &lt;&lt; <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        ++mp[(i - <span class="number">1</span>) / blksz + <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        pre[i] = lst[x]; lst[x] = i;</span><br><span class="line">        modify(pre[i], w[x]);</span><br><span class="line">        ans += query(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%llu"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 分块 </tag>
            
            <tag> 随机化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[BZOJ4915]简单的数字题</title>
      <link href="2018/12/24/BZOJ4915/"/>
      <url>2018/12/24/BZOJ4915/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4915" target="_blank" rel="noopener">题目链接</a></p><p>设$a_1 &lt; a_2 &lt; a_3 &lt; a_4$，$S = a_1 + a_2 + a_3 + a_4$，则$\frac{S}{2} &lt; a_2 + a_4 &lt; a_3 + a_4 &lt; S$。所以$a_2 + a_4$和$a_3 + a_4$不整除$S$。那么第一问的答案$\leqslant 4$，通过观察样例，我们发现第一问的答案$= 4$。</p><p>$\frac{S}{2} \leqslant \max(a_1 + a_4, a_2 + a_3) &lt; S$，所以$a_1 + a_4 = a_2 + a_3 = \frac{S}{2}$。</p><p>设$u = a_1 + a_2$，$v = a_1 + a_3$，则$S = 2(a_2 + a_3) = 2(u + v − 2a_1)$。</p><p>因为$v|s$，所以$v|2(u−2a_1)$。因为$u&lt;v$，所以$1 \leqslant \frac{2(u−2a_1)}{v}&lt;2$。所以$v=2(u−2a_1)$。</p><p>因为$u|s$，所以$u|2(v−2a_1)$。因为$2(v−2a_1)=2(2(u−2a_1)−2a_1)=4u−12a_1$，所以$u|12a_1$。</p><p>因为$u&lt;v$，所以$u&lt;2(u−2a_1)$，所以$u&gt;4a_1$。所以$u=6a_1$或$u=12a_1$。所以$A=\lbrace a_1,5a_1,7a_1,11a_1\rbrace$或$A=\lbrace a_1,11a_1,19a_1,29a_1\rbrace$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, l, r;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;l, &amp;r);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"4\n%lld"</span>, max(r / <span class="number">11</span> - l + <span class="number">1</span>, <span class="number">0l</span>l) + max(r / <span class="number">29</span> - l + <span class="number">1</span>, <span class="number">0l</span>l));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIP2018游记</title>
      <link href="2018/11/10/NOIP2018/"/>
      <url>2018/11/10/NOIP2018/</url>
      
        <content type="html"><![CDATA[<p>NOIP2018爆零记。</p><a id="more"></a><h3 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h3><p>由于今年我们学校是主办方，所以就没法住宾馆，只能住寝室。<del>(不能随意颓废了。。。)</del></p><p>然而考前颓废有助于发挥是常识，于是我就冒着被查表的风险开始在机房放飞自我了。</p><p>晚上看了几集番，刷了会知乎(看各路神仙对NOIP的毒奶)，由于要求提前回去睡觉，于是在8:30就回寝室睡觉了。</p><h3 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h3><p>早上由于要出发去紫金港，所以6:30就起床了。然后就带上了自己的电脑，在车上看了几集番。</p><p>到了紫金港，和同学奶了几波NOIP的题<del>(和贺指导)</del>就进考场了。</p><p>然后开题。</p><p>看到€€£换了评测机很开心，觉得不会卡常了。</p><p>先看T1，一开始想每次贪心减整个序列，最小值减成0后再分治下去。想一想发现这个做法要建笛卡尔树，显然不是T1难度。然后想倒过来从大到小枚举来做上面的过程，相等的段可以用并查集维护。然后觉得这好像也不是T1难度。最后思考了一下，发现自己sb了，这题似乎和前天的NOIP模拟题T1似乎一模一样，瞎贪心一波就好了。然后随便写写就写完了。</p><p>然后看T2，看完之后先大力猜一波结论，感觉如果一个数可以被其他数表示出来就把它删掉就好了。然后随便证明了一下(大概就是最小值肯定得选，然后次小值如果不能被最小值表示出来也就肯定得选，以此类推)。然后就是个无脑背包了。</p><p>最后开了T3，做好了题目很♂dark♂的准备。看完题后，显然得二分答案。二分完之后题目变成了最多能选多少条长度$\geqslant v$的边不相交的链。首先必须得先最大化每个子树内的路径数，在最大化路径数的前提下需要最大化从子树的根向下的最长的没有边被选的链。然后这个东西怎么转移呢，我们要做的就是拼接两个子树的向下的链。如果只是要求最大化路径数就直接sort一下然后从大到小用two pointers贪心一下，如果还要求剩下的向下的链尽可能长，我们就二分一下哪条剩下，然后直接再用前面的贪心check一下看答案会不会变就行了。</p><p>由于这次T3出乎意料的简单，导致我三道题写完后10:00都没到，于是就开始颓emacs的小隔膜到比赛结束。。。</p><p>出考场后发现大部分人都ak了，感觉难题都被放Day2了。</p><p>默写了考场代码后测了测洛谷数据，发现都过了。然后发现T1是NOIP2013原题，数据范围都没改。(€€£: 我抄我自己)</p><p>Day2爆炸预定。。。</p><h3 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h3><p>咕了一个星期的Day2游记。。。</p><p>开场看题，先看了看T1，很快写完了，然后开T2。</p><p>看到T2这么长的题面，突然有一种不好的预感，然后看到了数据范围$n \leqslant 8$，感觉这是一道状压题。</p><p>做了一会儿，发现矩阵合法的条件:</p><ol><li><p>一个数不能小于它右上角的数。</p></li><li><p>如果一个数和它右上角的数相等，那么它右边的格子到终点的所以路径都必须相同。</p></li></ol><p>然后我觉得这个东西太复杂了，一定有更优美的性质(最后好像并没有)，然后就准备打个暴力看一下矩阵的性质。</p><p>打了暴力没有发现什么性质，然而发现了在$n &gt; 1$，$m$很大时答案都是乘$3$，然后发现我的暴力只能跑$5 \times 5$。看了看发现$n \leqslant 3$有$65$分，然后就不管了。</p><p>然后还剩两个小时，看T3，发现没啥思维难度，是道码农题。由于我以为其他人都会T2，我觉得我只能靠T3拉回局面，然后就硬着头皮写T3的满分做法了。还好在比赛结束前拍上了，然后就不管了。</p><p>出考场后发现没多少人会T2，暂时松了一口气。</p><p>感觉把一年的RP都用在NOIP上了。。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Miller Rabin 算法和 Pollard Rho 算法</title>
      <link href="2018/10/25/miller-rabin-pollard-rho/"/>
      <url>2018/10/25/miller-rabin-pollard-rho/</url>
      
        <content type="html"><![CDATA[<h3 id="Miller-Rabin"><a href="#Miller-Rabin" class="headerlink" title="Miller Rabin"></a>Miller Rabin</h3><p>Miller Rabin 是一个快速判断质数的方法。</p><p>$a^{x-1} \equiv 1 \pmod x(1 \leqslant a \leqslant x - 1)$这个等式，在$x$是质数的时候根据费马小定理是成立的。在$x$不是质数的时候，这个等式有大概率不成立。</p><p>那么我们$\text{rand}$几个$a$，如果有至少一次不成立，就说明$x$不是质数，否则$x$有大概率是质数。多$\text{rand}$几次，正确率就会很高。</p><p>然而，对于某些合数，这个等式对大多数(甚至全部)的$a$都是成立的。于是我们需要加特技。</p><p>如果$a^b \equiv 1 \pmod x$($x$是质数且$b$是偶数)，那么$a^{\frac{b}{2}} \equiv 1 \pmod x$ 或 $a^{\frac{b}{2}} \equiv x - 1 \pmod x$。</p><p>假设$x - 1 = c \times 2^d$，如果$x$是质数：</p><ul><li><p>如果$a^{c \times 2^d} \equiv 1 \pmod x$，那么$a^{c \times 2^{d - 1}} \equiv 1 \pmod x$或$a^{c \times 2^{d - 1}} \equiv x - 1 \pmod x$。</p></li><li><p>如果$a^{c \times 2^{d - 1}} \equiv 1 \pmod x$，那么$a^{c \times 2^{d - 2}} \equiv 1 \pmod x$或$a^{c \times 2^{d - 2}} \equiv x - 1 \pmod x$。</p></li></ul><p>以此类推，如果$a^{c \times 2^{d - k}} \equiv 1 \pmod x$，那么$a^{c \times 2^{d - k - 1}} \equiv 1 \pmod x$或$a^{c \times 2^{d - k - 1}} \equiv x - 1 \pmod x$。</p><p>这些条件只要有一条不满足，那么$x$就不是质数。</p><p>据说这东西对于固定的$a$做一次的错误率约为$\frac{1}{4}$，如果多$\text{rand}$几次，正确率会很高。</p><h3 id="Pollard-Rho"><a href="#Pollard-Rho" class="headerlink" title="Pollard Rho"></a>Pollard Rho</h3><p>Pollard Rho 是一个快速分解质因数的方法。</p><p>如果要分解$x$的质因数，先用 Miller Rabin 判断$x$是不是质数，如果是的话就不用分解了。否则我们需要找到一个数$g$使得$1 &lt; g &lt; x$并且$g$是$x$的约数，之后我们再递归分解$g$和$\frac{x}{g}$即可。</p><p>接下来的问题就是如何找到$g$。</p><p>先随便定义一个函数$f$，例如$f(i) = i^2 + t$($t$为任意正整数)。</p><p>你有一个正整数$p$，每次把$p$变成$f(p)$，直到$p$在模$x$意义下变成了某一个数两次后停止。那么这个操作的执行次数大约是$O(\sqrt{x})$的。</p><p>感性理解一下就是把$f$在模$x$意义下看作一个随机函数，那么大约随机$O(\sqrt{x})$次就会产生重复(和生日悖论差不多)。</p><p>如果$x$不是质数，那么一定能找到一个$g \leqslant \sqrt{x}$。进行多次把$p$变成$f(p)$的操作，那么在模$g$意义下产生重复的期望次数要明显高于在模$x$意义下重复的期望次数。</p><p>再感性理解一下，在模$g$意义下产生重复而不在模$x$意义下产生重复的期望次数约为$O(\sqrt{g}) \leqslant O (x^{\frac{1}{4}})$(因为$g \leqslant \sqrt{x}$)。</p><p>我们再考虑另一个问题，如果每次把$p$变成$f(p)$，如何快速找到在模$x$意义下发生重复的时间？(不一定要是第一次重复)</p><p>当然直接开个$set$存出现过的值是可以的，但是这里说以下另一个做法。我们开一个变量$q$，当进行操作的次数为$2$的幂次时，把$q$赋值为$p$。每次变换完，我们看一下$p$和$q$是否相等。如果$p$和$q$相等，那么我们就找到了发生重复的两个时间。</p><p>关于这个做法的复杂度，感性理解是不会超过第一次重复的时间的常数倍的，那么也是大约$O(\sqrt{x})$的。</p><p>接下来我们就讲一下 Pollard Rho 中是如何找$g$的。</p><p>一开始随机一个函数$f$和一个初始值$p$，每次操作把$p$变成$f(p)$。</p><p>再开一个变量$q$，当进行操作的次数为$2$的幂次时，把$q$赋值为$p$。</p><p>每次变换完，我们看一下$|p - q|$和$x$的最大公约数。如果这个数$ &gt; 1$且$ &lt; x$，那么这个数就是我们要找的$g$。</p><p>如果操作完$p$和$q$相等了，我们就找到了一次重复，那么再进行多少次操作都找不到$g$了，就重新随机$f$和$p$，从头再做一遍。</p><p>关于复杂度，如果找到了一个$g$，那么说明它在模$g$意义下产生了重复并且没有在模$x$意义下产生重复，根据上面的分析(<del>感性理解</del>)，是$O(x ^ {\frac{1}{4}})$的。</p><p>由于在分解质因数过程中，上面的过程会被调用$O(\log{x})$次，所以总复杂度是$O(x^{\frac{1}{4}}\log{x})$(忽略快(<del>慢</del>)速乘的复杂度)。</p><p><a href="https://www.luogu.org/problemnew/show/P4718" target="_blank" rel="noopener">题目链接(<del>垃圾题目卡我常数，最后对着数据打表才过</del>)</a></p><p>以下代码删去了输入输出<del>和打表</del>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> millerrabin &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> testcnt = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">add</span><span class="params">(ll x, ll y, ll mod)</span> </span>&#123;</span><br><span class="line">        x += y; <span class="keyword">return</span> x &lt; mod ? x : x - mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">mul</span><span class="params">(ll x, ll y, ll mod)</span> </span>&#123;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (y) &#123;</span><br><span class="line">            <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ans = add(ans, x, mod);</span><br><span class="line">            y &gt;&gt;= <span class="number">1</span>; x = add(x, x, mod);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">fpow</span><span class="params">(ll x, ll y, ll mod)</span> </span>&#123;</span><br><span class="line">        ll ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (y) &#123;</span><br><span class="line">            <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ans = mul(ans, x, mod);</span><br><span class="line">            y &gt;&gt;= <span class="number">1</span>; x = mul(x, x, mod);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">main</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= testcnt; ++i) &#123;</span><br><span class="line">            ll v = rand() % (x - <span class="number">1</span>) + <span class="number">1</span>, now = fpow(v, x - <span class="number">1</span>, x);</span><br><span class="line">            <span class="keyword">if</span> (now != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (ll t = x - <span class="number">1</span>; ~t &amp; <span class="number">1</span>; t &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                now = fpow(v, t &gt;&gt; <span class="number">1</span>, x);</span><br><span class="line">                <span class="keyword">if</span> (now == x - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (now != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> pollardrho &#123;</span><br><span class="line">    <span class="keyword">using</span> millerrabin::add;</span><br><span class="line">    <span class="keyword">using</span> millerrabin::mul;</span><br><span class="line">    <span class="built_in">vector</span>&lt;ll&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (millerrabin::main(x)) ans.push_back(x);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                ll p = rand() % (x - <span class="number">1</span>) + <span class="number">1</span>, q = p, d = rand() % (x - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; ; ++i) &#123;</span><br><span class="line">                    p = add(mul(p, p, x), d, x);</span><br><span class="line">                    <span class="keyword">if</span> (p == q) <span class="keyword">break</span>;</span><br><span class="line">                    ll g = __gcd(<span class="built_in">abs</span>(p - q), x);</span><br><span class="line">                    <span class="keyword">if</span> (g &gt; <span class="number">1</span> &amp;&amp; g &lt; x) &#123;</span><br><span class="line">                        solve(g); solve(x / g);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((i &amp; -i) == i) q = p;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;ll&gt; <span class="title">main</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">        ans.clear();</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">1</span>) solve(x);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个求自然数幂和的naive做法</title>
      <link href="2018/10/23/power-of-number/"/>
      <url>2018/10/23/power-of-number/</url>
      
        <content type="html"><![CDATA[<p>qwq..</p><h3 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h3><p>$ \Big \lbrace { n \atop k } \Big \rbrace $为第二类斯特林数，即把将一个有$n$件物品的集合划分为$k$个非空子集的方法数。</p><p>$ x^{\underline{y}} = \prod_{i=0}^{y-1}(x-i) $称作下降幂。</p><h3 id="一些式子"><a href="#一些式子" class="headerlink" title="一些式子"></a>一些式子</h3><p>$$ \Big \lbrace { n \atop k } \Big \rbrace  = k \Big \lbrace { n - 1 \atop k } \Big \rbrace + \Big \lbrace { n - 1 \atop k - 1 } \Big \rbrace $$</p><p>递推式，考虑第$n$个元素所在的集合，可能自己一个集合，也可能和其他元素在一个集合。</p><p>$$ \Big \lbrace { n \atop k } \Big \rbrace = \frac{1}{k!} \sum_{i=0}^{k} (-1)^{k - i} {k \choose i} i^n $$</p><p>将一个有$n$件物品的集合划分为$k$个有标号可空子集的方法数为$k^n$，通过这个来容斥。</p><p>$$ x^k=\sum_{i=0}^{k}\Big \lbrace { k \atop i} \Big \rbrace x^{\underline{i}} $$</p><p>将一个有$k$件物品的集合划分为$x$个有标号可空子集的方法数为$x^k$，这也可以通过枚举有多少个子集是空的得到。</p><p>$$ (x+1)^{\underline{k+1}} - x^{\underline{k+1}} = (x + 1) x ^ {\underline{k}} - x ^ {\underline{k}} (x - k) = (k + 1) x^{\underline{k}} $$</p><p>$$ x^{\underline{k}} = \frac{(x+1)^{\underline{k+1}} - x^{\underline{k+1}}}{k + 1} $$</p><p>$$ \sum_{i=0}^{n}i^{\underline{k}} = \sum_{i=0}^{n}\frac{(i+1)^{\underline{k+1}} - i^{\underline{k+1}}}{k+1} = \frac{(n+1)^{\underline{k+1}}}{k + 1} $$</p><p>下降幂的前缀和。</p><h3 id="自然数幂和"><a href="#自然数幂和" class="headerlink" title="自然数幂和"></a>自然数幂和</h3><p>$$ \sum_{i=0}^{n} i^k = \sum_{i=0}^n \sum_{j=0}^{k} \Big \lbrace {k \atop j} \Big \rbrace i^{\underline{j}} $$</p><p>$$ =\sum_{j=0}^{k} \Big \lbrace {k \atop j} \Big \rbrace \sum_{i=0}^{n} i^{\underline{j}} $$</p><p>$$ =\sum_{j=0}^{k} \Big \lbrace {k \atop j} \Big \rbrace \frac{(n+1)^{\underline{j+1}}}{j+1} $$</p><p>然后直接计算这个式子，我们就得到了一个和$n$无关的计算方法。</p><p><a href="https://www.51nod.com/onlineJudge/questionCode.html#!problemId=1228" target="_blank" rel="noopener">题目链接</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3000</span>, mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">int</span> t, k, s[maxn + <span class="number">10</span>][maxn + <span class="number">10</span>], inv[maxn + <span class="number">10</span>];</span><br><span class="line">ll n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x += y; <span class="keyword">return</span> x &lt; mod ? x : x - mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x -= y; <span class="keyword">return</span> x &lt; <span class="number">0</span> ? x + mod : x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1l</span>l * x * y % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prework</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    s[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxn; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">            s[i][j] = add(mul(j, s[i - <span class="number">1</span>][j]), s[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxn; ++i)</span><br><span class="line">        inv[i] = i == <span class="number">1</span> ? <span class="number">1</span> : dec(<span class="number">0</span>, mul(mod / i, inv[mod % i]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prework();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%d"</span>, &amp;n, &amp;k); <span class="keyword">int</span> t = (n + <span class="number">1</span>) % mod, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">            ans = add(ans, mul(s[k][i], mul(t, inv[i + <span class="number">1</span>])));</span><br><span class="line">            t = mul(t, ((n - i) % mod + mod) % mod);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>World Final 2013题解</title>
      <link href="2018/10/13/wf2013/"/>
      <url>2018/10/13/wf2013/</url>
      
        <content type="html"><![CDATA[<p>我好菜啊!</p><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>由于每个方格可以翻转或旋转，所以我们如果可以不考虑重合构造出一条无限长的链，就可以通过翻转来使它没有重合的问题(比如强制这条链的方向是向左上)。</p><p>然后设$f[i][j]$表示第$i$个方格，它和上一个方格相连的边是第$j$条，那么它就可以通过第$k(k \ne j)$条边和下一个方格相连。</p><p>这样我们对于每种转移连一条有向边，就构成了一张图，如果这张图有环，就说明可以有一条无限长的链。</p><p>如果直接建图边数是$O(n^2)$的，我们可以对于每一种边的符号建一个新点，向对应的状态连边，那么这样边数就变成$O(n)$的了。然后拓扑排序判环即可。</p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>这题好神仙啊，我自己肯定是想不出来的。</p><p>首先，最优的策略一定是在赢了$a$元或输了$b$元之后停止，因为当前状态只和赢或亏的钱数有关，而和如何到达这个状态无关。</p><p>设$f(i)$表示从赢了$i$元到结束获得的期望钱数，则$f(a)=a$， $f(-b)=-b(1 - x)$， $f(i) = p f(i + 1) + (1 - p) f(i - 1)$。</p><p>可以发现$f(i)$是个线性递推，利用特征方程可以解得$f(i)$的通项，然后就可以$O(1)$求答案，答案就是$f(0)$的值。</p><p>设$g(u, v)$表示$a=u$，$b=v$时$f(0)$的值，则可以发现对于$u$和$v$，$g$都是单峰的，并且<del>通过观察别人的代码</del>我们发现随着$u$的增大，使$g(u, v)$最大的$v$是递增的。</p><p>然后我们信仰$u$和$v$不会很大，直接枚举$u$，然后将$v$增大至使$g(u, v)$最大的值即可。</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>只有距离相等的人有可能会冲突，我们只加入可能在最短路中的边，然后对所有距离相等的人跑网络流即可。</p><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>$f(x)$只会和$x$的所有质因子的出现次数有关，且$x$的所有质因子的出现次数不会超过$log$值域。直接暴搜整数拆分，然后由于我们想让$x$尽可能小，所以我们对于出现次数越多的数，分配越小的质数，然后$f(x)$的值用组合数计算。</p><p>由于直接计算组合数有可能会出现爆long long的情况，还有可能中间过程爆了，但答案没有爆。我们直接使用质因数分解来算组合数。这样就只有乘法了，结果爆了long long可以直接判断。</p><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>如果一个变量在$0$号bank里，我们一定会不使用BSR访问它，否则我们只能使用BSR访问它。</p><p>考虑到变量只有$13$个，我们暴枚哪些变量放在$0$号bank里，然后我们只要求出BSR的更改次数即可。</p><p>我们先求出一个数组$a[i][j]$表示无视所有在$0$号bank中的变量后，第$i$个变量在第$j$个变量前一次被访问的次数。那么我们将其他变量分成$b-1$组，代价是所有$a[i][j]$($i$和$j$不在同一组)之和。对于如何分组最优，我们使用状压求解即可。</p><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>把数组排个序，容易发现每一个机器的两组中的最小值一定会在数组中相邻。然后我们二分答案，直接贪心选择尽可能靠前的相邻的数作为某一个机器的最小值。如果一个数没有被选择，它一定会属于最小值已经被确定的某一个机器。那么记一下所有最小值已经被确定的机器还能容纳多少个数即可。</p><h3 id="G"><a href="#G" class="headerlink" title="G"></a>G</h3><p>不会。。</p><h3 id="H"><a href="#H" class="headerlink" title="H"></a>H</h3><p>无脑区间dp，如果合并了两个区间，那么代价为总元素个数减最小值较小的那个区间中比另一个区间的最小值小的元素个数(可能有点绕)。</p><h3 id="I"><a href="#I" class="headerlink" title="I"></a>I</h3><p>枚举上边界，枚举下边界，然后把每一列看做一个点，点的深度为这一列在上下边界之间的所有点的深度的最小值。</p><p>然后枚举底面的深度(在矩阵中的区域中的最小值)，那么底面面积越大越好，即左边界和右边界的距离要尽可能大。</p><p>用单调栈求出每个点左边和右边第一个比它大的数，就可以得到深度为这个点的深度的最大矩形。然后把这个矩阵和$a \times b$的大小限制取个$\min$，我们就得到了最大的底面面积。那么最高的高度显然是可以$O(1)$求的。</p><h3 id="J"><a href="#J" class="headerlink" title="J"></a>J</h3><p>计算几何题，考虑到精度要求不高，写辛普森积分调调参就可以过了。</p><h3 id="K"><a href="#K" class="headerlink" title="K"></a>K</h3><p>毒瘤码农题，先暴枚遍历的方式，然后状态是是否知道前、中、后序遍历，以及前、中、后序遍历所在的区间。然后记忆化一下即可。</p><p>由于太长了，我就不写了，口胡一下。。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CTSC2015]shallot(葱)</title>
      <link href="2018/10/10/CTSC2015-shallot/"/>
      <url>2018/10/10/CTSC2015-shallot/</url>
      
        <content type="html"><![CDATA[<p>感觉自己数据结构水平越来越菜了。。。</p><p><a href="https://www.luogu.org/problemnew/show/P4509" target="_blank" rel="noopener">题目链接</a></p><p>这个东西我想不出什么靠谱的做法，但是发现如果没有修改，用kd树很容易乱搞。在每个节点上维护框住所有点的矩形，如果查询的直线和这个矩形有交就往下做(这个kd树甚至都不能按坐标划分，但它跑得飞快)</p><p>然后修改和可持久化怎么做呢？我们考虑用类似treap的结构维护这棵kd树，然后修改就变成一个log的了。<del>但是查询还是O(玄学)的</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> ld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> fastio &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> sig = <span class="number">0</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">        <span class="keyword">while</span> ((c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &amp;&amp; c != <span class="string">'-'</span>) c = getchar();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'-'</span>) &#123;</span><br><span class="line">            sig = <span class="number">1</span>; c = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">            x = x * <span class="number">10</span> + c - <span class="string">'0'</span>; c = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sig) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(ll &amp;x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> sig = <span class="number">0</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">        <span class="keyword">while</span> ((c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &amp;&amp; c != <span class="string">'-'</span>) c = getchar();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'-'</span>) &#123;</span><br><span class="line">            sig = <span class="number">1</span>; c = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">            x = x * <span class="number">10</span> + c - <span class="string">'0'</span>; c = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sig) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> &amp;c)</span> </span>&#123;</span><br><span class="line">        c = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isgraph</span>(c)) c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">double</span> &amp;x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> sig = <span class="number">0</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">        <span class="keyword">while</span> ((c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &amp;&amp; c != <span class="string">'-'</span>) c = getchar();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'-'</span>) &#123;</span><br><span class="line">            sig = <span class="number">1</span>; c = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">            x = x * <span class="number">10</span> + c - <span class="string">'0'</span>; c = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'.'</span>) &#123;</span><br><span class="line">            c = getchar(); <span class="keyword">double</span> w = <span class="number">0.1</span>;</span><br><span class="line">            <span class="keyword">while</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">                x += (c - <span class="string">'0'</span>) * w;</span><br><span class="line">                c = getchar(); w /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sig) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(ld &amp;x)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> sig = <span class="number">0</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">        <span class="keyword">while</span> ((c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &amp;&amp; c != <span class="string">'-'</span>) c = getchar();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'-'</span>) &#123;</span><br><span class="line">            sig = <span class="number">1</span>; c = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">            x = x * <span class="number">10</span> + c - <span class="string">'0'</span>; c = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'.'</span>) &#123;</span><br><span class="line">            c = getchar(); <span class="keyword">double</span> w = <span class="number">0.1</span>;</span><br><span class="line">            <span class="keyword">while</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">                x += (c - <span class="string">'0'</span>) * w;</span><br><span class="line">                c = getchar(); w /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sig) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> type, <span class="keyword">typename</span>... types&gt;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(type &amp;x, types&amp;... y)</span> </span>&#123;</span><br><span class="line">            read(x);</span><br><span class="line">            read(y...);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> fastio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200000</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, c;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vec</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;a[maxn + <span class="number">10</span>];</span><br><span class="line">vec <span class="keyword">operator</span> + (<span class="keyword">const</span> vec &amp;a, <span class="keyword">const</span> vec &amp;b) &#123;</span><br><span class="line">    <span class="keyword">return</span> (vec)&#123;a.x + b.x, a.y + b.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line">vec <span class="keyword">operator</span> - (<span class="keyword">const</span> vec &amp;a, <span class="keyword">const</span> vec &amp;b) &#123;</span><br><span class="line">    <span class="keyword">return</span> (vec)&#123;a.x - b.x, a.y - b.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line">ll <span class="keyword">operator</span> | (<span class="keyword">const</span> vec &amp;a, <span class="keyword">const</span> vec &amp;b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1l</span>l * a.x * b.y - <span class="number">1l</span>l * a.y * b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sig</span><span class="params">(ll v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v &lt; <span class="number">0</span> ? <span class="number">-1</span> : v &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">line</span> &#123;</span></span><br><span class="line">    vec st, to;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cross</span><span class="params">(<span class="keyword">const</span> line &amp;a, <span class="keyword">const</span> line &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sig(a.to | (b.st - a.st)) * sig(a.to | (b.st + b.to - a.st)) &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kdtreap &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> maxc = maxn * <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mnx[maxc + <span class="number">10</span>], mxx[maxc + <span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> mny[maxc + <span class="number">10</span>], mxy[maxc + <span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> lc[maxc + <span class="number">10</span>], rc[maxc + <span class="number">10</span>], sz[maxc + <span class="number">10</span>], ndcnt;</span><br><span class="line">    vec val[maxc + <span class="number">10</span>], lv[maxc + <span class="number">10</span>], rv[maxc + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rnd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rand() % (x + y) &lt; x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mnx[<span class="number">0</span>] = mny[<span class="number">0</span>] = inf;</span><br><span class="line">        mxx[<span class="number">0</span>] = mxy[<span class="number">0</span>] = -inf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        sz[p] = sz[lc[p]] + sz[rc[p]] + <span class="number">1</span>;</span><br><span class="line">        mnx[p] = min(val[p].x, min(mnx[lc[p]], mnx[rc[p]]));</span><br><span class="line">        mxx[p] = max(val[p].x, max(mxx[lc[p]], mxx[rc[p]]));</span><br><span class="line">        mny[p] = min(val[p].y, min(mny[lc[p]], mny[rc[p]]));</span><br><span class="line">        mxy[p] = max(val[p].y, max(mxy[lc[p]], mxy[rc[p]]));</span><br><span class="line">        <span class="keyword">if</span> (lc[p]) lv[p] = lv[lc[p]]; <span class="keyword">else</span> lv[p] = val[p];</span><br><span class="line">        <span class="keyword">if</span> (rc[p]) rv[p] = rv[rc[p]]; <span class="keyword">else</span> rv[p] = val[p];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">iscross</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">const</span> line &amp;o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cross(o, (line)&#123;(vec)&#123;mnx[p], mny[p]&#125;, (vec)&#123;mxx[p] - mnx[p], <span class="number">0</span>&#125;&#125;) ||</span><br><span class="line">               cross(o, (line)&#123;(vec)&#123;mnx[p], mny[p]&#125;, (vec)&#123;<span class="number">0</span>, mxy[p] - mny[p]&#125;&#125;) ||</span><br><span class="line">               cross(o, (line)&#123;(vec)&#123;mxx[p], mxy[p]&#125;, (vec)&#123;mnx[p] - mxx[p], <span class="number">0</span>&#125;&#125;) ||</span><br><span class="line">               cross(o, (line)&#123;(vec)&#123;mxx[p], mxy[p]&#125;, (vec)&#123;<span class="number">0</span>, mny[p] - mxy[p]&#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">copy</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        ++ndcnt; </span><br><span class="line">        mnx[ndcnt] = mnx[p]; mxx[ndcnt] = mxx[p];</span><br><span class="line">        mny[ndcnt] = mny[p]; mxy[ndcnt] = mxy[p];</span><br><span class="line">        lc[ndcnt] = lc[p]; rc[ndcnt] = rc[p]; sz[ndcnt] = sz[p];</span><br><span class="line">        val[ndcnt] = val[p]; lv[ndcnt] = lv[p]; rv[ndcnt] = rv[p];</span><br><span class="line">        <span class="keyword">return</span> ndcnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">const</span> vec &amp;a)</span> </span>&#123;</span><br><span class="line">        ++ndcnt; val[ndcnt] = a;</span><br><span class="line">        update(ndcnt); <span class="keyword">return</span> ndcnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pair&lt;int, int&gt; split(int p, int k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!p) <span class="keyword">return</span> make_pair(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        p = copy(p); pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; r;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= sz[lc[p]]) &#123;</span><br><span class="line">            r = split(lc[p], k);</span><br><span class="line">            lc[p] = r.second; update(r.second = p);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = split(rc[p], k - sz[lc[p]] - <span class="number">1</span>);</span><br><span class="line">            rc[p] = r.first; update(r.first = p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y;</span><br><span class="line">        <span class="keyword">if</span> (rnd(sz[x], sz[y])) &#123;</span><br><span class="line">            x = copy(x); rc[x] = merge(rc[x], y);</span><br><span class="line">            update(x); <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            y = copy(y); lc[y] = merge(x, lc[y]);</span><br><span class="line">            update(y); <span class="keyword">return</span> y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        val[mid] = a[mid];</span><br><span class="line">        lc[mid] = build(l, mid - <span class="number">1</span>);</span><br><span class="line">        rc[mid] = build(mid + <span class="number">1</span>, r);</span><br><span class="line">        update(mid); <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">const</span> line &amp;o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p || !iscross(p, o)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (lc[p])</span><br><span class="line">            ans += cross(o, (line)&#123;val[p], rv[lc[p]] - val[p]&#125;) + query(lc[p], o);</span><br><span class="line">        <span class="keyword">if</span> (rc[p])</span><br><span class="line">            ans += cross(o, (line)&#123;val[p], lv[rc[p]] - val[p]&#125;) + query(rc[p], o);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> rt[maxn + <span class="number">10</span>], lst;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n, m, c);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(a[i].x, a[i].y);</span><br><span class="line">    kdtreap::init(); rt[<span class="number">0</span>] = kdtreap::build(<span class="number">1</span>, n);</span><br><span class="line">    kdtreap::ndcnt = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch; <span class="keyword">int</span> t, k; vec st, to;</span><br><span class="line">        read(ch);</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'H'</span>) &#123;</span><br><span class="line">            read(t, st.x, st.y, to.x, to.y);</span><br><span class="line">            <span class="keyword">if</span> (c) &#123;</span><br><span class="line">                st.x ^= lst; st.y ^= lst;</span><br><span class="line">                to.x ^= lst; to.y ^= lst;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, lst = kdtreap::query(rt[t], (line)&#123;st, to&#125;));</span><br><span class="line">            rt[i] = rt[t];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            read(t, k, st.x, st.y);</span><br><span class="line">            <span class="keyword">if</span> (c) &#123;</span><br><span class="line">                st.x ^= lst; st.y ^= lst;</span><br><span class="line">            &#125;</span><br><span class="line">            pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; r = kdtreap::split(rt[t], k);</span><br><span class="line">            rt[i] = kdtreap::merge(r.first, kdtreap::merge(kdtreap::newnode(st), r.second));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> kd树 </tag>
            
            <tag> 平衡树 </tag>
            
            <tag> 可持久化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World!</title>
      <link href="2018/10/05/hello-world/"/>
      <url>2018/10/05/hello-world/</url>
      
        <content type="html"><![CDATA[<h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><p>test</p><p><em>test</em></p><p><del>test</del></p><p><a href="https://www.codeforces.com" target="_blank" rel="noopener">test</a></p><ul><li>test</li><li>test</li><li>test</li></ul><ol><li>test</li><li>test</li><li>test</li></ol><p>$$ \sum_{i=1}^{n} i = \frac{n \times (n + 1)}{2}$$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
